<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>KartRider Ultra: 360 Full Control</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; font-family: 'Malgun Gothic', sans-serif; }
        #ui { position: absolute; top: 20px; left: 20px; color: white; text-shadow: 2px 2px 4px #000; pointer-events: none; }
        #speedo { font-size: 50px; font-weight: bold; color: #00ffff; font-style: italic; }
        #gauge-container { position: absolute; bottom: 40px; right: 40px; width: 300px; height: 25px; background: rgba(0,0,0,0.7); border: 2px solid #fff; border-radius: 20px; overflow: hidden; }
        #gauge-fill { width: 0%; height: 100%; background: linear-gradient(90deg, #ff00cc, #3333ff); box-shadow: 0 0 15px #ff00cc; }
        #status-msg { position: absolute; bottom: 75px; right: 45px; color: #ff00cc; font-weight: bold; font-size: 20px; display: none; }
        #info { position: absolute; bottom: 20px; width: 100%; text-align: center; color: #ccc; font-size: 14px; pointer-events: none; }
    </style>
</head>
<body>
    <div id="ui">
        <div id="speedo"><span id="speed">0</span> <small>km/h</small></div>
        <div style="color: #ff00cc; font-weight: bold;">BOOSTER READY: [SPACE]</div>
    </div>
    <div id="status-msg">BOOSTER ACTIVATE!!</div>
    <div id="gauge-container"><div id="gauge-fill"></div></div>
    <div id="info">마우스 왼쪽 드래그: 360도 지형 탐색 | 휠: 줌 | 방향키: 운전 | Shift: 드리프트 | Space: 부스터</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- 씬 기본 설정 ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a15);
        scene.fog = new THREE.Fog(0x0a0a15, 100, 800);

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(0, 10, -20); // 초기 카메라 위치

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // --- 마우스 자유 회전 컨트롤 (OrbitControls) ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // 부드러운 움직임
        controls.dampingFactor = 0.05;
        controls.minDistance = 5;
        controls.maxDistance = 300; // 맵 전체를 볼 수 있도록 거리 확장
        controls.autoRotate = false; // 수동 회전 우선

        // 조명
        scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        const sun = new THREE.DirectionalLight(0xffffff, 1.2);
        sun.position.set(100, 200, 50);
        sun.castShadow = true;
        scene.add(sun);

        // --- 지형 및 서킷 확장 ---
        const floorGeo = new THREE.PlaneGeometry(2000, 2000);
        const floorMat = new THREE.MeshPhongMaterial({ color: 0x111111 });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // 트랙 (8자형 거대 서킷)
        const trackPoints = [
            new THREE.Vector3(0, 0, 100), new THREE.Vector3(250, 0, 250),
            new THREE.Vector3(500, 0, 0), new THREE.Vector3(200, 0, -250),
            new THREE.Vector3(0, 0, -100), new THREE.Vector3(-250, 0, 100),
            new THREE.Vector3(-500, 0, -100), new THREE.Vector3(-250, 0, -300),
        ];
        const trackCurve = new THREE.CatmullRomCurve3(trackPoints, true);
        const trackGeo = new THREE.TubeGeometry(trackCurve, 200, 35, 12, true);
        const trackMat = new THREE.MeshPhongMaterial({ color: 0x252525 });
        const track = new THREE.Mesh(trackGeo, trackMat);
        track.scale.y = 0.01; track.position.y = 0.1;
        track.receiveShadow = true;
        scene.add(track);

        // --- 자동차 제작 (디테일 3D 모델) ---
        function createKart(color, isPlayer = false) {
            const kart = new THREE.Group();
            
            // 본체
            const body = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.8, 4.5), new THREE.MeshPhongMaterial({ color }));
            body.position.y = 0.6; body.castShadow = true;
            kart.add(body);

            // 스포일러
            const wingTop = new THREE.Mesh(new THREE.BoxGeometry(3, 0.2, 1.2), new THREE.MeshPhongMaterial({ color }));
            wingTop.position.set(0, 1.8, 1.8);
            kart.add(wingTop);
            const support = new THREE.Mesh(new THREE.BoxGeometry(0.2, 1, 0.2), new THREE.MeshPhongMaterial({ color: 0x444444 }));
            const s1 = support.clone(); s1.position.set(1, 1.2, 1.8); kart.add(s1);
            const s2 = support.clone(); s2.position.set(-1, 1.2, 1.8); kart.add(s2);

            // 바퀴
            const wGeo = new THREE.CylinderGeometry(0.7, 0.7, 0.6, 20);
            const wMat = new THREE.MeshPhongMaterial({ color: 0x111111 });
            const wPositions = [[1.4, 0.7, 1.5], [-1.4, 0.7, 1.5], [1.4, 0.7, -1.5], [-1.4, 0.7, -1.5]];
            wPositions.forEach(p => {
                const w = new THREE.Mesh(wGeo, wMat);
                w.rotation.z = Math.PI / 2;
                w.position.set(...p);
                kart.add(w);
            });

            // 부스터 불꽃
            const flame = new THREE.Mesh(new THREE.ConeGeometry(0.6, 2.5, 12), new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.8 }));
            flame.rotation.x = -Math.PI / 2;
            flame.position.set(0, 0.8, 2.8);
            flame.visible = false;
            kart.add(flame);

            scene.add(kart);
            return { mesh: kart, vel: 0, rot: 0, flame, isBoosting: false, progress: Math.random() };
        }

        const player = createKart(0xffd700, true); // 플레이어 황금카트
        player.mesh.position.set(0, 0, 100);

        const ais = [createKart(0xff3333), createKart(0x33ff33), createKart(0x3333ff)];
        ais.forEach((ai, i) => ai.mesh.position.set(-15 + i*10, 0, 115));

        // --- 로직 제어 변수 ---
        const keys = {};
        let boosterGauge = 0;
        const BASE_MAX = 0.85;
        const BOOST_MAX = 1.6;
        const ACCEL = 0.008;

        window.onkeydown = (e) => { keys[e.code] = true; };
        window.onkeyup = (e) => keys[e.code] = false;

        function update() {
            // 1. 플레이어 이동 로직
            const currentMax = player.isBoosting ? BOOST_MAX : BASE_MAX;
            
            if (keys['ArrowUp'] || keys['KeyW']) player.vel += ACCEL;
            else if (keys['ArrowDown'] || keys['KeyS']) player.vel -= ACCEL;
            else player.vel *= 0.98; // 자연 감속

            player.vel = Math.max(-0.3, Math.min(currentMax, player.vel));

            // 부스터 실행 (Space 키)
            if (keys['Space'] && boosterGauge >= 100 && !player.isBoosting) {
                player.isBoosting = true;
                player.flame.visible = true;
                boosterGauge = 0;
                document.getElementById('status-msg').style.display = 'block';
                setTimeout(() => {
                    player.isBoosting = false;
                    player.flame.visible = false;
                    document.getElementById('status-msg').style.display = 'none';
                }, 3000);
            }

            // 핸들링 및 드리프트
            if (Math.abs(player.vel) > 0.05) {
                let rotSpeed = 0.04;
                if (keys['ShiftLeft']) { 
                    rotSpeed = 0.07; // 드리프트 시 회전력 강화
                    player.vel *= 0.992;
                    if (boosterGauge < 100) boosterGauge += 0.6;
                }
                if (keys['ArrowLeft'] || keys['KeyA']) player.rot += rotSpeed;
                if (keys['ArrowRight'] || keys['KeyD']) player.rot -= rotSpeed;
            }

            player.mesh.rotation.y = player.rot;
            player.mesh.position.x += Math.sin(player.rot) * player.vel;
            player.mesh.position.z += Math.cos(player.rot) * player.vel;

            // 2. AI 주행 (플레이어와 동일 밸런스)
            ais.forEach(ai => {
                ai.progress += 0.0015;
                if (ai.progress > 1) ai.progress = 0;
                const p = trackCurve.getPointAt(ai.progress);
                const np = trackCurve.getPointAt((ai.progress + 0.01) % 1);
                ai.mesh.position.lerp(new THREE.Vector3(p.x, 0, p.z), 0.1);
                ai.mesh.lookAt(np.x, 0, np.z);
            });

            // 3. 카메라 & 360도 컨트롤 업데이트
            // 사용자가 마우스를 클릭(드래그)하고 있지 않을 때만 자동차를 자동으로 따라감
            if (!keys['MouseDown']) {
                const idealOffset = new THREE.Vector3(0, 7, -18).applyMatrix4(player.mesh.matrixWorld);
                camera.position.lerp(idealOffset, 0.1);
                controls.target.lerp(player.mesh.position, 0.1);
            }
            
            controls.update();

            // 4. UI 업데이트
            document.getElementById('speed').innerText = Math.round(player.vel * 250);
            document.getElementById('gauge-fill').style.width = boosterGauge + '%';

            renderer.render(scene, camera);
            requestAnimationFrame(update);
        }

        // 마우스 클릭 상태 감지
        window.addEventListener('mousedown', () => keys['MouseDown'] = true);
        window.addEventListener('mouseup', () => keys['MouseDown'] = false);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        update();
    </script>
</body>
</html>